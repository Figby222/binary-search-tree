Create a factory called Tree
    return an object with the following properties:
        root: buildTree()

Create a function buildTree which takes an array
    Set sortedArr = the return value of mergeSort(array)

    set root = balanceTree(sortedArr)

    return root


Create a function mergeSort that takes an array
    If arg.length <= 1
        return arg

    Set sortedArr = []
    
    Set arrayLeft = mergeSort(arg.slice(0, (arg.length() - 1) / 2))
    set arrayRight = mergeSort(arg.slice((arg.length() - 1) / 2))

    set sortedArr = sortNums(arrayLeft, arrayRight)

    return sortedArr

Create a function sortNums that takes arrayLeft and arrayRight
    set leftI = 0; rightI = 0; sortedI = 0;
    set sorted = []
    while leftI is less than arrayLeft length or rightI is less than arrayRight length
        if arrayLeft[leftI] < arrayRight[rightI] and leftI is less than arrayLeft.length()
            Set sorted[sortedI] = arrayLeft[leftI]
            increment sortedI and leftI
        else if arrayLeft[leftI] > arrayRight[rightI] and rightI is less than arrayLeft.length()
            Set sorted[sortedI] = arrayRight[rightI]
            increment sortedI and rightI
        else
            break
    
    return sorted

    
Create a function balanceTree which takes a sorted array

    return null if arg.length <= 0

    Set mid = (arg.length - 1) / 2

    Set node = new Node(arg[mid])
    
    Set node.left = balanceTree(arg.slice(0, mid))
    Set node.right = balanceTree(arg.slice(mid + 1))

    return node

Create a function deleteItem(value)
    The following will follow in the case that the value is a leaf node
        Create function recursion(root = this.root)
            The following are assuming the node is a leaf node
                if root.left != null and value == root.left.data
                    root.left = null
                    return
                otherwise if root.right != null and value == root.right.data
                    root.right = null
                    return
                otherwise if root.data == null
                    return
                otherwise if value < root.data
                    return recursion(root.left)
                otherwise if value > root.data
                    return recursion(root.right)



Create function inorder(root, value) 
    If root is null
        return;
    Otherwise call inorder(root.left, value)
    If root data is equal to value
        return root
    Otherwise call inorder(root.right, value)

Create function levelOrder(node = this.root, callback = levelOrderDefault)
    set right to node.right
    set left to node.left
    If typeof callBack == levelOrderDefault
        if node is null return []

        set array to empty array

        Push callback(node) to array
        push levelOrder(right) to array
        push levelOrder(left) to array

        return array concatenated with levelOrder(node)
    Otherwise call callback(node)
    Call levelOrder(right)
    Call levelOrder(left)

Create function levelOrder(node = this.root, callback = levelOrderDefault)
    set right to node.right
    set left to node.left
    If typeof callBack == levelOrderDefault
        if node is null return []

        set array to empty array

        Push callback(node) to array
        push levelOrder(right) to array
        push levelOrder(left) to array
        
        return array concatenated with levelOrder(node)
    Otherwise call callback(node)
    Call levelOrder(right)
    Call levelOrder(left)

createfunction levelOrderDefault(node)
    